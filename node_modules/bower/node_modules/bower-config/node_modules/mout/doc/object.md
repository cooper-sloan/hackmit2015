# object #

Object utilities.



## bindAll(obj, [...methodNames]):void

Bind methods of the target object to always execute on its own context
(ovewritting the original function).

See: [function/bind](./function.html#bind)

```js
var view = {
    name: 'Lorem Ipsum',
    logNameOnClick: function() {
        console.log(this.name);
    }
};

// binds all methods by default
bindAll(view);
jQuery('#docs').on('click', view.logNameOnClick);
```

You can also specify the list of methods that you want to bind (in case you
just want to bind a few of them).

```js
// only the listed methods will be bound to `obj` context
bindAll(obj, 'logNameOnClick', 'doAwesomeStuffOnDrag');
```



## contains(obj, value):Boolean

Similar to [Array/contains](array.html#contains). Checks if Object contains
value.

```js
var obj = {
    a: 1,
    b: 2,
    c: 'bar'
};
contains(obj, 2);      // true
contains(obj, 'foo');  // false
```



## deepEquals(a, b, [callback]):Boolean

Recursively tests whether two objects contain the same keys and equal values.

`callback` specifies the equality comparison function used to compare
non-object values. It defaults to using the strict equals (`===`) operator.

If the values are both an object, it will recurse into the objects, checking if
their keys/values are equal. It will only check the keys and values contained
by the objects; it will not check the objects' prototypes.  If the either of
the values are not objects, they will be checked using the `callback` function.

Example:

```js
deepEquals({ a: 1 }, { a: 1 }); // true
deepEquals({ value: { a: 1 } }, { value: { a: 1 } }); // true
deepEquals({ value: { a: 1 } }, { value: { a: 2 } }); // false
deepEquals({ value: { a: 1 } }, { value: { a: 1, b: 2 } }); // false
deepEquals({}, null); // false
deepEquals(null, null); // true
deepEquals(
    { a: { b: 1 } },
    { a: { b: '1' } },
    function(a, b) { return a == b; }); // true
```

See: [`equals()`](#equals)



## deepFillIn(target, ...objects):Object

Fill missing properties recursively.

It's different from `deepMixIn` since it won't override any existing property.
It's also different from `merge` since it won't clone child objects during the
process.

It returns the target object and mutates it in place.

See: [`fillIn()`](#fillIn), [`deepMixIn()`](#deepMixIn), [`merge()`](#merge)

```js
var base = {
    foo : {
        bar : 123
    },
    lorem : 'ipsum'
};
var options = deepFillIn({foo : { baz : 45 }, lorem : 'amet'}, base);
// > {foo: {bar:123, baz : 45}, lorem : 'amet'}
```



## deepMatches(target, pattern):Boolean

Recursively checks if object contains all properties/value pairs. When both
the target and pattern values are arrays, it checks that the target value
contain matches for all the items in the pattern array (independent of order).

```js
var john = {
    name: 'John',
    age: 22,
    pets: [
        { type: 'cat', name: 'Grumpy Cat' },
        { type: 'dog', name: 'Hawk' }
    ]
};

deepMatches(john, { name: 'John' }); // true
deepMatches(john, { age: 21 }); // false
deepMatches(jo