// Load modules

var Fs = require('fs');
var Path = require('path');
var Code = require('code');
var Hoek = require('../lib');
var Lab = require('lab');


// Declare internals

var internals = {};


// Test shortcuts

var lab = exports.lab = Lab.script();
var describe = lab.experiment;
var it = lab.test;
var expect = Code.expect;


var nestedObj = {
    v: [7, 8, 9],
    w: /^something$/igm,
    x: {
        a: [1, 2, 3],
        b: 123456,
        c: new Date(),
        d: /hi/igm,
        e: /hello/
    },
    y: 'y',
    z: new Date(1378775452757)
};

var dupsArray = [nestedObj, { z: 'z' }, nestedObj];
var reducedDupsArray = [nestedObj, { z: 'z' }];

describe('clone()', function () {

    it('clones a nested object', function (done) {

        var a = nestedObj;
        var b = Hoek.clone(a);

        expect(a).to.deep.equal(b);
        expect(a.z.getTime()).to.equal(b.z.getTime());
        done();
    });

    it('clones a null object', function (done) {

        var b = Hoek.clone(null);

        expect(b).to.equal(null);
        done();
    });

    it('should not convert undefined properties to null', function (done) {

        var obj = { something: undefined };
        var b = Hoek.clone(obj);

        expect(typeof b.something).to.equal('undefined');
        done();
    });

    it('should not throw on circular reference', function (done) {

        var a = {};
        a.x = a;

        var test = function () {

            var b = Hoek.clone(a);
        };

        expect(test).to.not.throw();
        done();
    });

    it('clones circular reference', function (done) {

        var x = {
            'z': new Date()
        };
        x.y = x;

        var b = Hoek.clone(x);
        expect(Object.keys(b.y)).to.deep.equal(Object.keys(x));
        expect(b.z).to.not.equal(x.z);
        expect(b.y).to.not.equal(x.y);
        expect(b.y.z).to.not.equal(x.y.z);
        expect(b.y).to.equal(b);
        expect(b.y.y.y.y).to.equal(b);
        done();
    });

    it('clones an object with a null prototype', function (done) {

        var obj = Object.create(null);
        var b = Hoek.clone(obj);

        expect(b).to.deep.equal(obj);
        done();
    });

    it('clones deeply nested object', function (done) {

        var a = {
            x: {
                y: {
                    a: [1, 2, 3],
                    b: 123456,
                    c: new Date(),
                    d: /hi/igm,
                    e: /hello/
                }
            }
        };

        var b = Hoek.clone(a);

        expect(a).to.deep.equal(b);
        expect(a.x.y.c.getTime()).to.equal(b.x.y.c.getTime());
        done();
    });

    it('clones arrays', function (done) {

        var a = [1, 2, 3];

        var b = Hoek.clone(a);

        expect(a).to.deep.equal(b);
        done();
    });

    it('performs actual copy for shallow keys (no pass by reference)', function (done) {

        var x = Hoek.clone(nestedObj);
        var y = Hoek.clone(nestedObj);

        // Date
        expect(x.z).to.not.equal(nestedObj.z);
        expect(x.z).to.not.equal(y.z);

        // Regex
        expect(x.w).to.not.equal(nestedObj.w);
        expect(x.w).to.not.equal(y.w);

        // Array
        expect(x.v).to.not.equal(nestedObj.v);
        expect(x.v).to.not.equal(y.v);

        // Immutable(s)
        x.y = 5;
        expect(x.y).to.not.equal(nestedObj.y);
        expect(x.y).to.not.equal(y.y);

        done();
    });

    it('performs actual copy for deep keys (no pass by reference)', function (done) {

        var x = Hoek.clone(nestedObj);
        var y = Hoek.clone(nestedObj);

        expect(x.x.c).to.not.equal(nestedObj.x.c);
        expect(x.x.c).to.not.equal(y.x.c);

        expect(x.x.c.getTime()).to.equal(nestedObj.x.c.getTime());
        expect(x.x.c.getTime()).to.equal(y.x.c.getTime());
        done();
    });

    it('copies functions with properties', function (done) {

        var a = {
            x: function () {

                return 1;
            },
            y: {}
        };
        a.x.z = 'string in function';
        a.x.v = function () {

            return 2;
        };
        a.y.u = a.x;

        var b = Hoek.clone(a);
        expect(b.x()).to.equal(1);
        expect(b.x.v()).to.equal(2);
        expect(b.y.u).to.equal(b.x);
        expect(b.x.z).to.equal('string in function');
        done();
    });

    it('should copy a buffer', function (done) {

        var tls = {
            key: new Buffer([1, 2, 3, 4, 5]),
            cert: new Buffer([1, 2, 3, 4, 5, 6, 10])
        };

        var copiedTls = Hoek.clone(tls);
        expect(Buffer.isBuffer(copiedTls.key)).to.equal(true);
        expect(JSON.stringify(copiedTls.key)).to.equal(JSON.stringify(tls.key));
        expect(Buffer.isBuffer(copiedTls.cert)).to.equal(true);
        expect(JSON.stringify(copiedTls.cert)).to.equal(JSON.stringify(tls.cert));
        done();
    });

    it('clones an object with a prototype', function (done) {

        var Obj = function () {

            this.a = 5;
        };

        Obj.prototype.b = function () {

            return 'c';
        };

        var a = new Obj();
        var b = Hoek.clone(a);

        expect(b.a).to.equal(5);
        expect(b.b()).to.equal('c');
        expect(a).to.deep.equal(b);
        done();
    });

    it('reuses cloned Date object', function (done) {

        var obj = {
            a: new Date()
        };

        obj.b = obj.a;

        var copy = Hoek.clone(obj);
        expect(copy.a).to.equal(copy.b);
        done();
    });

    it('shallow copies an object with a prototype and isImmutable flag', function (done) {

        var Obj = function () {

            this.value = 5;
        };

        Obj.prototype.b = function () {

            return 'c';
        };

        Obj.prototype.isImmutable = true;

        var obj = {
            a: new Obj()
        };

        var copy = Hoek.clone(obj);

        expect(obj.a.value).to.equal(5);
        expect(copy.a.value).to.equal(5);
        expect(copy.a.b()).to.equal('c');
        expect(obj.a).to.equal(copy.a);
        done();
    });

    it('clones an object with property getter without executing it', function (done) {

        var obj = {};
        var value = 1;
        var execCount = 0;

        Object.defineProperty(obj, 'test', {
            enumerable: true,
            configurable: true,
            get: function () {

                ++execCount;
                return value;
            }
        });

        var copy = Hoek.clone(obj);
        expect(execCount).to.equal(0);
        expect(copy.test).to.equal(1);
        expect(execCount).to.equal(1);
        done();
    });

    it('clones an object with property getter and setter', function (done) {

        var obj = {
            _test: 0
        };

        Object.defineProperty(obj, 'test', {
            enumerable: true,
            configurable: true,
            get: function () {

                return this._test;
            },
            set: function (value) {

                this._test = value - 1;
            }
        });

        var copy = Hoek.clone(obj);
        expect(copy.test).to.equal(0);
        copy.test = 5;
        expect(copy.test).to.equal(4);
        done();
    });

    it('clones an object with only property setter', function (done) {

        var obj = {
            _test: 0
        };

        Object.defineProperty(obj, 'test', {
            enumerable: true,
            configurable: true,
            set: function (value) {

                this._test = value - 1;
            }
        });

        var copy = Hoek.clone(obj);
        expect(copy._test).to.equal(0);
        copy.test = 5;
        expect(copy._test).to.equal(4);
        done();
    });

    it('clones an object with non-enumerable properties', function (done) {

        var obj = {
            _test: 0
        };

        Object.defineProperty(obj, 'test', {
            enumerable: false,
            configurable: true,
            set: function (value) {

                this._test = value - 1;
            }
        });

        var copy = Hoek.clone(obj);
        expect(copy._test).to.equal(0);
        copy.test = 5;
        expect(copy._test).to.equal(4);
        done();
    });
});

describe('merge()', function () {

    it('deep copies source items', function (done) {

        var target = {
            b: 3,
            d: []
        };

        var source = {
            c: {
                d: 1
            },
            d: [{ e: 1 }]
        };

        Hoek.merge(target, source);
        expect(target.c).to.not.equal(source.c);
        expect(target.c).to.deep.equal(source.c);
        expect(target.d).to.not.equal(source.d);
        expect(target.d[0]).to.not.equal(source.d[0]);
        expect(target.d).to.deep.equal(source.d);
        done();
    });

    it('merges array over an object', function (done) {

        var a = {
            x: ['n', 'm']
        };

        var b = {
            x: {
                n: '1',
                m: '2'
            }
        };

        Hoek.merge(b, a);
        expect(a.x[0]).to.equal('n');
        expect(a.x.n).to.not.exist();
        done();
    });

    it('merges object over an array', function (done) {

        var a = {
            x: ['n', 'm']
        };

        var b = {
            x: {
                n: '1',
                m: '2'
            }
        };

        Hoek.merge(a, b);
        expect(a.x.n).to.equal('1');
        expect(a.x[0]).to.not.exist();
        done();
    });

    it('does not throw if source is null', function (done) {

        var a = {};
        var b = null;
        var c = null;

        expect(function () {

            c = Hoek.merge(a, b);
        }).to.not.throw();

        expect(c).to.equal(a);
        done();
    });

    it('does not throw if source is undefined', function (done) {

        var a = {};
        var b;
        var c = null;

        expect(function () {

            c = Hoek.merge(a, b);
        }).to.not.throw();

        expect(c).to.equal(a);
        done();
    });

    it('throws if source is not an object', function (done) {

        expect(function () {

            var a = {};
            var b = 0;

            Hoek.merge(a, b);
        }).to.throw('Invalid source value: must be null, undefined, or an object');
        done();
    });

    it('throws if target is not an object', function (done) {

        expect(function () {

            var a = 0;
            var b = {};

            Hoek.merge(a, b);
        }).to.throw('Invalid target value: must be an object');
        done();
    });

    it('throws if target is not an array and source is', function (done) {

        expect(function () {

            var a = {};
            var b = [1, 2];

            Hoek.merge(a, b);
        }).to.throw('Cannot merge array onto an object');
        done();
    });

    it('returns the same object when merging arrays', function (done) {

        var a = [];
        var b = [1, 2];

        expect(Hoek.merge(a, b)).to.equal(a);
        done();
    });

    it('combines an empty object with a non-empty object', function (done) {

        var a = {};
        var b = nestedObj;

        var c = Hoek.merge(a, b);
        expect(a).to.deep.equal(b);
        expect(c).to.deep.equal(b);
        done();
    });

    it('overrides values in target', function (done) {

        var a = { x: 1, y: 2, z: 3, v: 5, t: 'test', m: 'abc' };
        var b = { x: null, z: 4, v: 0, t: { u: 6 }, m: '123' };

        var c = Hoek.merge(a, b);
        expect(c.x).to.equal(null);
        expect(c.y).to.equal(2);
        expect(c.z).to.equal(4);
        expect(c.v).to.equal(0);
        expect(c.m).to.equal('123');
        expect(c.t).to.deep.equal({ u: 6 });
        done();
    });

    it('overrides values in target (flip)', function (done) {

        var a = { x: 1, y: 2, z: 3, v: 5, t: 'test', m: 'abc' };
        var b = { x: null, z: 4, v: 0, t: { u: 6 }, m: '123' };

        var d = Hoek.merge(b, a);
        expect(d.x).to.equal(1);
        expect(d.y).to.equal(2);
        expect(d.z).to.equal(3);
        expect(d.v).to.equal(5);
        expect(d.m).to.equal('abc');
        expect(d.t).to.deep.equal('test');
        done();
    });

    it('retains Date properties', function (done) {

        var a = { x: new Date(1378776452757) };

        var b = Hoek.merge({}, a);
        expect(a.x.getTime()).to.equal(b.x.getTime());
        done();
    });

    it('retains Date properties when merging keys', function (done) {

        var a = { x: new Date(1378776452757) };

        var b = Hoek.merge({ x: {} }, a);
        expect(a.x.getTime()).to.equal(b.x.getTime());
        done();
    });

    it('overrides Buffer', function (done) {

        var a = { x: new Buffer('abc') };

        var b = Hoek.merge({ x: {} }, a);
        expect(a.x.toString()).to.equal('abc');
        done();
    });
});

describe('applyToDefaults()', function () {

    var defaults = {
        a: 1,
        b: 2,
        c: {
            d: 3,
            e: [5, 6]
        },
        f: 6,
        g: 'test'
    };

    it('throws when target is null', function (done) {

        expect(function () {

            Hoek.applyToDefaults(null, {});
        }).to.throw('Invalid defaults value: must be an object');
        done();
    });

    it('returns null if options is false', function (done) {

        var result = Hoek.applyToDefaults(defaults, false);
        expect(result).to.equal(null);
        done();
    });

    it('returns null if options is null', function (done) {

        var result = Hoek.applyToDefaults(defaults, null);
        expect(result).to.equal(null);
        done();
    });

    it('returns null if options is undefined', function (done) {

        var result = Hoek.applyToDefaults(defaults, undefined);
        expect(result).to.equal(null);
        done();
    });

    it('returns a copy of defaults if options is true', function (done) {

        var result = Hoek.applyToDefaults(defaults, true);
        expect(result).to.deep.equal(defaults);
        done();
    });

    it('applies object to defaults', function (done) {

        var obj = {
            a: null,
            c: {
                e: [4]
            },
            f: 0,
            g: {
                h: 5
            }
        };

        var result = Hoek.applyToDefaults(defaults, obj);
        expect(result.c.e).to.deep.equal([4]);
        expect(result.a).to.equal(1);
        expect(result.b).to.equal(2);
        expect(result.f).to.equal(0);
        expect(result.g).to.deep.equal({ h: 5 });
        done();
    });

    it('applies object to defaults with null', function (done) {

        var obj = {
            a: null,
            c: {
                e: [4]
            },
            f: 0,
            g: {
                h: 5
            }
        };

        var result = Hoek.applyToDefaults(defaults, obj, true);
        expect(result.c.e).to.deep.equal([4]);
        expect(result.a).to.equal(null);
        expect(result.b).to.equal(2);
        expect(result.f).to.equal(0);
        expect(result.g).to.deep.equal({ h: 5 });
        done();
    });
});

describe('cloneWithShallow()', function () {

    it('deep clones except for listed keys', function (done) {

        var source = {
            a: {
                b: 5
            },
            c: {
                d: 6
            }
        };

        var copy = Hoek.cloneWithShallow(source, ['c']);
        expect(copy).to.deep.equal(source);
        expect(copy).to.not.equal(source);
        expect(copy.a).to.not.equal(source.a);
        expect(copy.b).to.equal(source.b);
        done();
    });

    it('returns immutable value', function (done) {

        expect(Hoek.cloneWithShallow(5)).to.equal(5);
        done();
    });

    it('returns null value', function (done) {

        expect(Hoek.cloneWithShallow(null)).to.equal(null);
        done();
    });

    it('returns undefined value', function (done) {

        expect(Hoek.cloneWithShallow(undefined)).to.equal(undefined);
        done();
    });

    it('deep clones except for listed keys (including missing keys)', function (done) {

        var source = {
            a: {
                b: 5
            },
            c: {
                d: 6
            }
        };

        var copy = Hoek.cloneWithShallow(source, ['c', 'v']);
        expect(copy).to.deep.equal(source);
        expect(copy).to.not.equal(source);
        expect(copy.a).to.not.equal(source.a);
        expect(copy.b).to.equal(source.b);
        done();
    });
});

describe('applyToDefaultsWithShallow()', function () {

    it('shallow copies the listed keys from options without merging', function (done) {

        var defaults = {
            a: {
                b: 5,
                e: 3
            },
            c: {
                d: 7,
                g: 1
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                d: 6,
                f: 7
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['a']);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { d: 6, g: 1, f: 7 } });
        expect(merged.a).to.equal(options.a);
        expect(merged.a).to.not.equal(defaults.a);
        expect(merged.c).to.not.equal(options.c);
        expect(merged.c).to.not.equal(defaults.c);
        done();
    });

    it('shallow copies the nested keys (override)', function (done) {

        var defaults = {
            a: {
                b: 5
            },
            c: {
                d: 7,
                g: 1
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                d: 6,
                g: {
                    h: 8
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { d: 6, g: { h: 8 } } });
        expect(merged.c.g).to.equal(options.c.g);
        done();
    });

    it('shallow copies the nested keys (missing)', function (done) {

        var defaults = {
            a: {
                b: 5
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                g: {
                    h: 8
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { g: { h: 8 } } });
        expect(merged.c.g).to.equal(options.c.g);
        done();
    });

    it('shallow copies the nested keys (override)', function (done) {

        var defaults = {
            a: {
                b: 5
            },
            c: {
                g: {
                    d: 7
                }
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                g: {
                    h: 8
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { g: { h: 8 } } });
        expect(merged.c.g).to.equal(options.c.g);
        done();
    });

    it('shallow copies the nested keys (deeper)', function (done) {

        var defaults = {
            a: {
                b: 5
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                g: {
                    r: {
                        h: 8
                    }
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g.r']);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { g: { r: { h: 8 } } } });
        expect(merged.c.g.r).to.equal(options.c.g.r);
        done();
    });

    it('shallow copies the nested keys (not present)', function (done) {

        var defaults = {
            a: {
                b: 5
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                g: {
                    r: {
                        h: 8
                    }
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['x.y']);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { g: { r: { h: 8 } } } });
        done();
    });

    it('shallow copies the listed keys in the defaults', function (done) {

        var defaults = {
            a: {
                b: 1
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, {}, ['a']);
        expect(merged.a).to.equal(defaults.a);
        done();
    });

    it('shallow copies the listed keys in the defaults (true)', function (done) {

        var defaults = {
            a: {
                b: 1
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, true, ['a']);
        expect(merged.a).to.equal(defaults.a);
        done();
    });

    it('returns null on false', function (done) {

        var defaults = {
            a: {
                b: 1
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, false, ['a']);
        expect(merged).to.equal(null);
        done();
    });

    it('throws on missing defaults', function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow(null, {}, ['a']);
        }).to.throw('Invalid defaults value: must be an object');
        done();
    });

    it('throws on invalid defaults', function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow('abc', {}, ['a']);
        }).to.throw('Invalid defaults value: must be an object');
        done();
    });

    it('throws on invalid options', function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow({}, 'abc', ['a']);
        }).to.throw('Invalid options value: must be true, falsy or an object');
        done();
    });

    it('throws on missing keys', function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow({}, true);
        }).to.throw('Invalid keys');
        done();
    });

    it('throws on invalid keys', function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow({}, true, 'a');
        }).to.throw('Invalid keys');
        done();
    });
});

describe('deepEqual()', function () {

    it('compares simple values', function (done) {

        expect(Hoek.deepEqual('x', 'x')).to.be.true();
        expect(Hoek.deepEqual('x', 'y')).to.be.false();
        expect(Hoek.deepEqual('x1', 'x')).to.be.false();
        expect(Hoek.deepEqual(-0, +0)).to.be.false();
        expect(Hoek.deepEqual(-0, -0)).to.be.true();
        expect(Hoek.deepEqual(+0, +0)).to.be.true();
        expect(Hoek.deepEqual(+0, -0)).to.be.false();
        expect(Hoek.deepEqual(1, 1)).to.be.true();
        expect(Hoek.deepEqual(0, 0)).to.be.true();
        expect(Hoek.deepEqual(-1, 1)).to.be.false();
        expect(Hoek.deepEqual(NaN, 0)).to.be.false();
        expect(Hoek.deepEqual(NaN, NaN)).to.be.true();
        done();
    });

    it('compares diffe